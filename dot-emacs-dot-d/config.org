#+TITLE: Emacs Config
#+AUTHOR: Akash Agrawal
#+EMAIL: akagr@outlook.com
#+PROPERTY: header-args :results silent :tangle "./init.el"
#+STARTUP: content
#+babel: :cache yes

This is my [[https://www.gnu.org/software/emacs/][Emacs]] config, written using [[https://orgmode.org][Org]] in literate environment. I use this primarily on macOS and haven't tested it on other platforms, but I imagine most of the code works with minor to no changes on Linux and possibly Windows too.

* Early Init
:properties:
:header-args+: :tangle "./early-init.el"
:end:

** Defer Compilation
#+BEGIN_SRC emacs-lisp
  (defvar comp-deferred-compilation)
  (setq comp-deferred-compilation t)
#+END_SRC

** Speed Boost
#+BEGIN_SRC emacs-lisp
  (setq package-enable-at-startup nil
        frame-inhibit-implied-resize t)
#+END_SRC

** Reduce GC
Following [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][Doom-Emacs FAQ]], we max the garbage collection threshold on startup, and reset it to the original value after.
#+BEGIN_SRC emacs-lisp
  ;; max memory available for gc on startup
  (defvar aa/gc-cons-threshold 16777216)
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold aa/gc-cons-threshold
                    gc-cons-percentage 0.1)))

  ;; max memory available for gc when opening minibuffer
  (defun aa/defer-garbage-collection-h ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun aa/restore-garbage-collection-h ()
    ;; Defer it so that commands launched immediately after will enjoy the
    ;; benefits.
    (run-at-time
     1 nil (lambda () (setq gc-cons-threshold aa/gc-cons-threshold))))

  (add-hook 'minibuffer-setup-hook #'aa/defer-garbage-collection-h)
  (add-hook 'minibuffer-exit-hook #'aa/restore-garbage-collection-h)
  (setq garbage-collection-messages nil)
#+END_SRC

Temporarily avoid special handling of files
#+BEGIN_SRC emacs-lisp
  (defvar aa/-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq file-name-handler-alist aa/-file-name-handler-alist)))
#+END_SRC

** Disable Site Run
#+BEGIN_SRC emacs-lisp
  (setq site-run-file nil)
#+END_SRC

** Don't compact font caches
#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

** Improve I/O
Optimizations for improving I/O performance. Increase max bytes read from a sub-process in a single op (Emacs 27+)
#+BEGIN_SRC emacs-lisp
  (when (boundp 'read-process-output-max)
    ;; 1MB in bytes, default 4096 bytes
    (setq read-process-output-max 1048576))
#+END_SRC

** Straight.el
[[https://github.com/raxod502/straight.el][straight.el]] is used to download packages for us from all over the web. It stores them all in their respective git folders in =.emacs.d/straight=, which makes debugging, and contributing fixes back upstream as easy as possible.

Updating some settings so straight.el can play nicely with use-package.
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t
        straight-cache-autoloads t
        straight-check-for-modifications '(check-on-save)
        straight-vc-git-default-clone-depth 1
        vc-follow-symlinks t)
#+END_SRC

Fetching =straight.el=.
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (setq vc-follow-symlinks 'ask) ; restore default
#+END_SRC

Loading an optional package which gives us some convenience functions, like ~straight-x-clean-unused-repo~ to remove any packages we don't have configured anymore.
#+begin_src emacs-lisp
  (require 'straight-x)
#+end_src

Installing =use-package= now.
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
#+END_SRC

** Load Diminish
#+BEGIN_SRC emacs-lisp
  ;; (when (require "diminish" nil t)
  ;;   (message "Diminish loaded"))
#+END_SRC
** Use the garbage collector magic hack
#+begin_src emacs-lisp
  (use-package gcmh
    :demand t
    :diminish
    :config (gcmh-mode 1))
  #+end_src
** End early init
#+BEGIN_SRC emacs-lisp
  (provide 'early-init)
#+END_SRC

* External Dependencies

- Download ~elixir-ls~ from https://github.com/JakeBecker/elixir-ls and adjust the path of language server in eglot config.

* Bootstrapping and Default

** Setup load path
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+END_SRC

** Update defaults
Turn off auto backup files, startup message and other more sensible defaults.
#+BEGIN_SRC emacs-lisp
  (setq auto-save-default nil
        create-lockfiles nil
        make-backup-files nil
        inhibit-startup-message t
        load-prefer-newer t
        ring-bell-function 'ignore
        sentence-end-double-space nil
        confirm-kill-processes nil)
#+END_SRC

Don't use tabs for indentation. Also truncate lines instead of wrapping them.
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                truncate-lines t)
#+END_SRC

Use y or n instead of yes or no. Additionally, use ibuffers to be consistent with buffer management and not having to worry about wrong key chords.
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  (defalias 'list-buffers 'ibuffer)
#+END_SRC

Turn off all the chrome that emacs puts by default.
#+BEGIN_SRC emacs-lisp
  (progn
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (tooltip-mode -1))
#+END_SRC

A few modes are turned on by default
#+BEGIN_SRC emacs-lisp
  (global-so-long-mode) ;; handles really long lines well
  (electric-pair-mode) ;; auto matching brackets, parentheses etc.
  (show-paren-mode) ;; show matching opening/closing parentheses
  (column-number-mode) ;; show column number in mode line
  (global-display-line-numbers-mode) ;; show line numbers in all buffers
#+END_SRC

Make the command key behave as 'meta' on macOS.
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq mac-option-key-is-meta nil
          mac-command-key-is-meta t
          mac-command-modifier 'meta
          mac-option-modifier 'super))
#+END_SRC

Delete whitespace on save
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-change-major-mode-hook
            (lambda ()
              (modify-syntax-entry ?_ "w")))
#+END_SRC

* Custom Functions

** Copy current file path relative to project root.
#+BEGIN_SRC emacs-lisp
  (defun aa/copy-file-path ()
    "Copy file path of current buffer relative to project root."
    (interactive)
    (kill-new (file-relative-name buffer-file-name (projectile-project-root))))

  (defalias 'copy-file-path 'aa/copy-file-path)
#+END_SRC

** Kill this buffer and window, as long as it's not the only window open.
#+begin_src emacs-lisp
  (defun aa/close-and-kill-this-pane ()
    "If there are multiple windows, then close this one and kill its buffer"
    (interactive)
    (kill-this-buffer)
    (if (not (one-window-p))
        (delete-window)))
#+end_src

** Add custom methods to correctly locate elixir and rails projects inside a multi-project monorepo.
#+BEGIN_SRC emacs-lisp
  (defun aa/find-mix-project (dir)
    "Try to locate a Elixir project root by 'mix.exs' above DIR."
    (let ((mix_root (locate-dominating-file dir "mix.exs")))
      (message "Found Elixir project root in '%s' starting from '%s'" mix_root dir)
      (if (stringp mix_root) `(transient . ,mix_root) nil)))

  (defun aa/find-rails-project (dir)
    "Try to locate a Rails project root by 'Gemfile' above DIR."
    (let ((rails_root (locate-dominating-file dir "Gemfile")))
      (message "Found Rails project root in '%s' starting from '%s'" rails_root dir)
      (if (stringp rails_root) `(transient . ,rails_root) nil)))
#+END_SRC

** Print emacs startup time
#+BEGIN_SRC emacs-lisp
  (defun aa/print-startup-time ()
    "Log emacs startup time"
    (interactive)
    (message "Emacs started in %s with %d garbage collections."
             (format
              "%.2f seconds"
              (float-time
               (time-subtract after-init-time before-init-time)))
             gcs-done))
#+END_SRC

** Auto tangle this file after save
#+BEGIN_SRC emacs-lisp
  (use-package async
    :demand t)

  (defvar *config-file* (expand-file-name "config.org" user-emacs-directory)
    "The configuration file.")

  (defvar *show-async-tangle-results* nil
    "Keeps *emacs* async buffers around for later inspection.")

  (defun aa/async-babel-tangle (org-file)
    "Tangles the org file asynchronously."
    (let ((init-tangle-start-time (current-time))
          (file (buffer-file-name))
          (async-quiet-switch "-q"))
      (async-start
       `(lambda ()
          (require 'ob-tangle)
          (org-babel-tangle-file ,org-file))
       (unless *show-async-tangle-results*
         `(lambda (result)
            (if result
                (message "SUCCESS: %s successfully tangled (%.2fs)."
                         ,org-file
                         (float-time
                          (time-subtract (current-time)
                                         ',init-tangle-start-time)))
              (message "ERROR: %s as tangle failed." ,org-file)))))))

  (defun aa/config-tangle ()
    "Tangles the org file asynchronously."
    (aa/async-babel-tangle *config-file*))

  (add-hook 'org-mode-hook
            (lambda ()
              (when (and buffer-file-truename
                         (equal (file-name-nondirectory buffer-file-truename)
                                "config.org"))
                (add-hook 'after-save-hook
                          'aa/config-tangle
                          nil 'make-it-local))))
#+END_SRC

** Convert strings to dash case
#+BEGIN_SRC emacs-lisp
  (defun aa/dashcase (str)
    "Converts a string to dash case.

     Example:
     (aa/dashcase \"Hello World\")
     => \"hello-world\" "
    (let ((down (downcase str)))
      (replace-regexp-in-string "\\([^A-Za-z]\\)" "-" down)))
#+END_SRC
* Support Packages

Loading emacs from finder or spotlight causes it to not load many environment variables. This package fixes it.
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

Various packages that are used by numerous other packages.
+ `which-key` allows using keybindings interactively. For example, if `<leader>gs` is mapped to `magit-status`, and I press only `<leader>g`, it'll show all the keys and commands that are valid follows.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish
    :config
    (which-key-mode)
    (which-key-setup-side-window-bottom)
    :custom (which-key-idle-delay 0.3))
#+END_SRC

Simplify leader bindings with general.el.
#+begin_src emacs-lisp
  (use-package general
    :config
    (general-evil-setup t)

    (general-create-definer aa/leader-key-def
      :keymaps '(normal insert visual emacs)
      :prefix ","
      :global-prefix "C-,"))
#+end_src
* Common Keybindings

#+BEGIN_SRC emacs-lisp
  (aa/leader-key-def
    "e"  '(:ignore t :which-key "emacs")
    "ee" '((lambda () (interactive) (find-file (expand-file-name "config.org" user-emacs-directory))) :which-key "open config")
    "er" '((lambda () (interactive) (load-file user-init-file)) :which-key "reload config")
    "ek" '(kill-emacs :which-key "kill emacs")

    "f"  '(:ignore t :which-key "file")
    "ff" '(find-file :which-key "find")

    "h"  '(help-command :which-key "help")

    "t"  '(:ignore t :which-key "toggle")
    "tt" '(load-theme :which-key "theme")
    "tw" '(toggle-truncate-lines :which-key "wrap lines")

    "c"  '(:ignore t :which-key "code")
    "ca" '(align-regexp :which-key "align regex")
    "cc" '(xref-find-definitions :which-key "find definitions")
    "ce" '(eval-last-sexp :which-key "eval last sexp")
    "cr" '(xref-find-references :which-key "find references"))
#+END_SRC
* Helpful Instrospection

[[https://github.com/Wilfred/helpful][Helpful]] allows much better help (introspection) pages. For example, when showing help for functions, it shows references, source code etc. all on single page. This reduces jumping to different locations frequently.
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key))
    :commands (helpful-callable
               helpful-variable
               helpful-key
               helpful-at-point
               helpful-command
               helpful-macro
               helpful-function))
#+END_SRC
* Appearance
** Frame dimensions

Set default frame height.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(width . 200))
  (add-to-list 'default-frame-alist '(height . 48))
#+END_SRC

** Font
#+BEGIN_SRC emacs-lisp
  (defun aa/apply-fonts (frame)
    "Apply selected fonts to emacs."

    ;; Set the font face based on platform
    (set-face-attribute 'default frame
                        :font "JetBrains Mono"
                        :weight 'regular
                        :height 150)

    ;; Set the fixed pitch face
    (set-face-attribute 'fixed-pitch frame
                        :font "JetBrains Mono"
                        :weight 'regular
                        :height 150)

    ;; Set the variable pitch face
    (set-face-attribute 'variable-pitch frame
                        :font "JetBrains Mono"
                        :height 150
                        :weight 'regular))

  (add-hook 'after-make-frame-functions
            (lambda (frame)
              (with-selected-frame frame
                (aa/apply-fonts frame))))

  (aa/apply-fonts nil)
#+END_SRC

Enable ligature support by using auto composition mode.
#+BEGIN_SRC emacs-lisp
  (let ((ligatures `((?-  . ,(regexp-opt '("-|" "-~" "---" "-<<" "-<" "--" "->" "->>" "-->")))
                     (?/  . ,(regexp-opt '("/**" "/*" "///" "/=" "/==" "/>" "//")))
                     (?*  . ,(regexp-opt '("*>" "***" "*/")))
                     (?<  . ,(regexp-opt '("<-" "<<-" "<=>" "<=" "<|" "<||" "<|||::=" "<|>" "<:" "<>" "<-<"
                                           "<<<" "<==" "<<=" "<=<" "<==>" "<-|" "<<" "<~>" "<=|" "<~~" "<~"
                                           "<$>" "<$" "<+>" "<+" "</>" "</" "<*" "<*>" "<->" "<!--")))
                     (?:  . ,(regexp-opt '(":>" ":<" ":::" "::" ":?" ":?>" ":=")))
                     (?=  . ,(regexp-opt '("=>>" "==>" "=/=" "=!=" "=>" "===" "=:=" "==")))
                     (?!  . ,(regexp-opt '("!==" "!!" "!=")))
                     (?>  . ,(regexp-opt '(">]" ">:" ">>-" ">>=" ">=>" ">>>" ">-" ">=")))
                     (?&  . ,(regexp-opt '("&&&" "&&")))
                     (?|  . ,(regexp-opt '("|||>" "||>" "|>" "|]" "|}" "|=>" "|->" "|=" "||-" "|-" "||=" "||")))
                     (?.  . ,(regexp-opt '(".." ".?" ".=" ".-" "..<" "...")))
                     (?+  . ,(regexp-opt '("+++" "+>" "++")))
                     (?\[ . ,(regexp-opt '("[||]" "[<" "[|")))
                     (?\{ . ,(regexp-opt '("{|")))
                     (?\? . ,(regexp-opt '("??" "?." "?=" "?:")))
                     (?#  . ,(regexp-opt '("####" "###" "#[" "#{" "#=" "#!" "#:" "#_(" "#_" "#?" "#(" "##")))
                     (?\; . ,(regexp-opt '(";;")))
                     (?_  . ,(regexp-opt '("_|_" "__")))
                     (?\\ . ,(regexp-opt '("\\" "\\/")))
                     (?~  . ,(regexp-opt '("~~" "~~>" "~>" "~=" "~-" "~@")))
                     (?$  . ,(regexp-opt '("$>")))
                     (?^  . ,(regexp-opt '("^=")))
                     (?\] . ,(regexp-opt '("]#"))))))
    (dolist (char-regexp ligatures)
      (set-char-table-range composition-function-table (car char-regexp)
                            `([,(cdr char-regexp) 0 font-shape-gstring]))))
#+END_SRC

Disable auto composition everywhere outside of prog-mode.
#+BEGIN_SRC emacs-lisp
  (global-auto-composition-mode -1)

  (defun aa/enable-auto-composition ()
    (auto-composition-mode))

  (add-hook 'prog-mode-hook #'aa/enable-auto-composition)
#+END_SRC
** Theme

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

  (setq aa/theme 'doom-one)

  (use-package doom-themes
    :config
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    (load-theme aa/theme t)
    (doom-themes-org-config))
#+END_SRC

Load theme after creating a new frame. This is required to work with server/client model. Otherwise, emacs will load theme only once when starting server and all subsequent frames won't get the theme.
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-make-frame-functions
            (lambda (frame)
              (with-selected-frame frame
                (load-theme aa/theme t))))
#+END_SRC

** Mode line

Config for mode line:
#+begin_src emacs-lisp
  ;; Diminish minor modes from mode line
  (use-package diminish
    :config
    (diminish 'org-indent-mode)
    (diminish 'buffer-face-mode)
    (diminish 'visual-line-mode)
    (diminish 'eldoc-mode)
    (diminish 'auto-revert-mode))
#+end_src
* Evil Mode

Add undo package to allow branching undos.
#+begin_src emacs-lisp
  (use-package undo-fu)
#+end_src

Being a long time (neo)vim user, I use evil mode exclusively for editing. When they say it's impossible to get out of vim, it has a deeper meaning.

I use different colored cursors to depict what mode I'm in. Way easier to work with than looking at minibuffer.
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq evil-respect-visual-line-mode t
          evil-undo-system 'undo-fu
          evil-want-integration t
          evil-want-keybinding nil)
    :config
    (evil-mode)
    (setq evil-emacs-state-modes (delq 'ibuffer-mode evil-emacs-state-modes)
          evil-emacs-state-cursor '("indian red" box)
          evil-normal-state-cursor '("indian red" box)
          evil-visual-state-cursor '("royal blue" box)
          evil-insert-state-cursor '("yellow green" box)
          evil-replace-state-cursor '("red" box)
          evil-operator-state-cursor '("red" hollow)))
#+END_SRC

Commentary package allows me to retain my muscle memory of (un)commenting code.
#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :after evil
    :diminish
    :config
    (evil-commentary-mode))
#+END_SRC

Evil surround for adding quotes, parenthesis etc. Another takeaway from vim.
#+begin_src emacs-lisp

  (use-package evil-surround
    :after evil
    :config
    (global-evil-surround-mode 1))
#+end_src

~evil-collection~ adds evil bindings for packages and modes not covered by ~evil~.
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :init
    (evil-collection-init
     '(deadgrep
       dired
       dired-sidebar
       ediff
       embark
       grep
       ibuffer
       magit
       occur
       vterm
       wgrep
       xref)))
#+END_SRC

[[https://github.com/gabesoft/evil-mc][evil-mc]] adds an awesome multiple cursor mode.
#+BEGIN_SRC emacs-lisp
  (use-package evil-mc
    :config
    (global-evil-mc-mode 1))
#+END_SRC

* Org Mode
:properties:
:header-args+: :tangle "./lisp/init-org.el"
:end:

** Load relevant config when org is loaded
This gets placed in ~init.el~ and requires all the code following it related to org mode.
#+BEGIN_SRC emacs-lisp :tangle "./init.el"
  (add-hook 'org-mode-hook
            (lambda ()
              (require 'init-org)))

  (with-eval-after-load 'org
    (setq org-startup-indented t
          org-hide-emphasis-markers t
          org-fontify-done-headline t
          org-hide-leading-stars t
          org-pretty-entities t
          org-src-fontify-natively t
          org-src-tab-acts-natively t
          truncate-lines nil))
#+END_SRC

** Align tags on save
#+BEGIN_SRC emacs-lisp :tangle "./init.el"
  (add-hook 'org-mode-hook
            (lambda ()
              (add-hook 'before-save-hook
                        (lambda ()
                          (org-align-tags t))
                        nil t)))
#+END_SRC

** Set up org default files and directories:

#+begin_src emacs-lisp
  (setq org-directory "~/Dropbox/org"
        org-default-notes-file (concat org-directory "/notes.org")
        org-agenda-files '("~/Dropbox/org/")
        org-archive-location (concat org-directory "/archive/%s::"))
#+end_src

** Show hidden elements under point
#+BEGIN_SRC emacs-lisp
  (use-package org-appear
    :custom
    (org-appear-autolinks t)
    (org-appear-submarkers t)
    (org-appear-delay 0.5)
    :hook (org-mode . org-appear-mode))

  ;; Start once on initial org load.
  ;; The hook above takes care of starting it on subsequent loads.
  (org-appear-mode)
#+END_SRC
** Keybindings for org mode.

#+begin_src emacs-lisp
  (aa/leader-key-def
    "r"  '(:ignore t :which-key "org mode")
    "ra" '(org-agenda :which-key "agenda")
    "rc" '(org-capture :which-key "capture")
    "ri" '((lambda () (interactive) (org-indent-block)) :which-key "indent block")
    "rl" '(org-store-link :which-key "store Link")
    "ro" '((lambda () (interactive) (find-file org-default-notes-file)) :which-key "open notes")
    "rp" '(org-present :which-key "present")
    "rt" '(org-babel-tangle :which-key "tangle"))
#+end_src

** Enable helpful org-specific minor modes

#+BEGIN_SRC emacs-lisp
  ;; Turn on visual line mode to wrap lines.
  (visual-line-mode)
  (add-hook 'org-mode-hook #'visual-line-mode)

  ;; Turn on variable pitch mode to use different scale for headings
  (variable-pitch-mode)
  (add-hook 'org-mode-hook #'variable-pitch-mode)

  ;; If the source block contains code that outputs images,
  ;; show them inline in results area.
  (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images)
#+END_SRC

** Org bullets

=org-bullets= package prettifies the headline markers.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :custom
    (org-bullets-bullet-list '("☯" "✸" "✿" "✜" "◆" "◉" "▶" "○"))
    :hook (org-mode . org-bullets-mode))

  ;; Start once on initial org load.
  ;; The hook above takes care of starting it on subsequent loads.
  (org-bullets-mode)
#+END_SRC

** Evil org mode

Helps with evil keybindings in =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :diminish
    :hook (org-mode . evil-org-mode)
    :init
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme)))
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))

  ;; Start once on initial org load.
  ;; The hook above takes care of starting it on subsequent loads.
  (evil-org-mode)
#+END_SRC

** Font and text customisation

Replace default block delimiters with ligatures
#+BEGIN_SRC emacs-lisp
  (setq-default prettify-symbols-alist '(("#+BEGIN_SRC" . "λ")
                                         ("#+END_SRC" . "λ")
                                         ("#+begin_src" . "λ")
                                         ("#+end_src" . "λ")))
  (setq prettify-symbols-unprettify-at-point t)

  (prettify-symbols-mode)
  (add-hook 'org-mode-hook 'prettify-symbols-mode)
#+END_SRC

Replace list bullets with prettier dots.
#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([+]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "◦"))))))
#+END_SRC

** Presentations with Org

Add ability to present org files.
#+BEGIN_SRC emacs-lisp
  (use-package org-present
    :commands (org-present)
    :config
    (add-hook 'org-present-mode-hook
                 (lambda ()
                   (display-line-numbers-mode -1)
                   (org-display-inline-images)
                   (org-present-hide-cursor)
                   (org-present-read-only)))
       (add-hook 'org-present-mode-quit-hook
                 (lambda ()
                   (display-line-numbers-mode +1)
                   (org-remove-inline-images)
                   (org-present-show-cursor)
                   (org-present-read-write))))
#+END_SRC
** Org drill
Allows preparing flashcard like interface for spaced repetition and revision. Check out the [[https://gitlab.com/phillord/org-drill/][repo]] for more info.
#+BEGIN_SRC emacs-lisp
  (use-package org-drill
    :commands (org-drill))
#+END_SRC
** Provide org package

Provide org package for ~require~.
#+BEGIN_SRC emacs-lisp
  (org-reload)
  (provide 'init-org)
#+END_SRC
* Better UX for Completions

Add =vertico= to handle all the menu presentation.
#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :init
    (vertico-mode)
    :custom
    (vertico-cycle t))
#+END_SRC

Save history of selections across emacs sessions.
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (savehist-mode))
#+END_SRC

Add =marginalia= for richer annotations in menus.
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :after vertico
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+END_SRC

Add =orderless= for saner ordering and filtering of completion candidates.
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless))
    (completion-category-defaults nil)
    (completion-category-overrides '(file (styles partial-completion))))
#+END_SRC


Add extra completion commands ala =consult=.
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :init
    (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    :config
    (setq consult-project-root-function #'projectile-project-root))
#+END_SRC

=embark= allows 'right-click' behaviour. i.e. it allows adding contextual actions to things.
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :custom
    ;; This effectively disables the comfirmation for anything not
    ;; listed.
    (embark-allow-edit-commands
     '(shell-command async-shell-command pp-eval-expression))

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))

    ;; Add ability to open in another window
    (eval-when-compile
      (defmacro aa/embark-ace-action (fn)
        "Add functions to open objects in other window."
        `(defun ,(intern (concat "aa/embark-ace-" (symbol-name fn))) ()
           (interactive)
           (with-demoted-errors "%s"
             (require 'ace-window)
             (let ((aw-dispatch-always t))
               (aw-switch-to-window (aw-select nil))
               (call-interactively (symbol-function ',fn)))))))

    (define-key embark-file-keymap     (kbd "o") (aa/embark-ace-action find-file))
    (define-key embark-buffer-keymap   (kbd "o") (aa/embark-ace-action switch-to-buffer))
    (define-key embark-bookmark-keymap (kbd "o") (aa/embark-ace-action bookmark-jump)))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :after (embark consult)
    :demand t ;; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

Add common keybindings for buffer.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states 'normal
   "C-s" 'consult-line)
#+END_SRC

* VCS

The primary git interface I use, and also one of the main reasons I use emacs. `libgit` provides native bindings which makes magit faster.
#+BEGIN_SRC emacs-lisp
  (use-package libgit)

  (use-package magit
    :commands (magit magit-status magit-blame))

  (use-package magit-libgit
    :after (magit libgit))

  (aa/leader-key-def
    "g" '(:ignore t :which-key "git")
    "gs" '(magit-status :which-key "status")
    "gb" '(magit-blame :which-key "blame"))
#+END_SRC

Set ediff to use the current frame instead of creating a new one.
#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

* Buffer and window management
** Ace window
~ace-window~ allows quickly switching between open windows (splits).
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :commands (ace-window)
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (aw-background nil))
#+END_SRC
** Buffer keybindings
#+BEGIN_SRC emacs-lisp
  (aa/leader-key-def
  "b"   '(:ignore t :which-key "buffer")
  "bb"  '(switch-to-buffer :which-key "list buffers")
  "bc"  '(kill-this-buffer :which-key "kill current")
  "bd"  '(aa/close-and-kill-this-pane :which-key "close current"))
#+END_SRC
** Window Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(normal insert visual)
   "M-o" 'ace-window)
#+END_SRC
* Dired

Set directories to be listed above files.
#+BEGIN_SRC emacs-lisp
  (defun aa/dired-sort-directories ()
    "Sort dired listings with directories first."
    (save-excursion
      (let (buffer-read-only)
        (forward-line 2) ;; beyond dir. header
        (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
      (set-buffer-modified-p nil)))

  (defadvice dired-readin
    (after dired-after-updating-hook first () activate)
    "Sort dired listings with directories first before adding marks."
    (aa/dired-sort-directories))
#+END_SRC

* Project Management

Projectile plays pretty well with the other packages, including magit and dired sidebar.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :after evil
    :diminish
    :init
    (setq projectile-enable-caching t)
    :config
    (define-key projectile-mode-map (kbd "M-p") 'projectile-command-map)
    (projectile-mode +1))

  (aa/leader-key-def
    "p"  '(projectile-command-map :which-key "projectile"))
#+END_SRC

* Programming Languages
** Common Config
#+begin_src emacs-lisp
  (use-package editorconfig
    :diminish
    :config
    (editorconfig-mode 1))
#+end_src
** Ruby
#+begin_src emacs-lisp
  (use-package ruby-end
    :hook (ruby-mode . ruby-end-mode)
    :diminish)
#+end_src
** Typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode ("\\.tsx?\\'" . typescript-mode))
#+end_src
** Elixir
#+BEGIN_SRC emacs-lisp
  (use-package elixir-mode
    :mode "\\.exs?\\'"
    :config
    ;; Activate ruby end mode on elixir. This helps auto-inserting
    ;; ruby style 'end' after writing 'do' in elixir.
    (add-hook 'elixir-mode-hook
              (lambda ()
                (set (make-variable-buffer-local 'ruby-end-expand-keywords-before-re)
                     "\\(?:^\\|\\s-+\\)\\(?:do\\)")
                (set (make-variable-buffer-local 'ruby-end-check-statement-modifiers) nil)
                (ruby-end-mode +1)))
    ;; Create a buffer-local hook to run elixir-format on save, only when we enable elixir-mode.
    (add-hook 'elixir-mode-hook
              (lambda () (add-hook 'before-save-hook 'elixir-format nil t))))
#+END_SRC
** Web
#+begin_src emacs-lisp
  (use-package web-mode
    :mode "\\.p?html?\\'"
    :mode "\\.eex\\'"
    :mode "\\.leex\\'"

    :config
    (setq
     web-mode-markup-indent-offset 2
     web-mode-css-indent-offset 2
     web-mode-code-indent-offset 2
     web-mode-enable-auto-closing t
     web-mode-enable-auto-opening t
     web-mode-enable-auto-pairing t
     web-mode-enable-auto-indentation t)
    )

  (use-package polymode
    :mode ("\\.ex\\'" . poly-elixir-web-mode)
    :config
    (define-hostmode poly-elixir-hostmode :mode 'elixir-mode)
    (define-innermode poly-liveview-expr-elixir-innermode
      :mode 'web-mode
      :head-matcher (rx line-start (* space) "~L" (= 3 (char "\"'")) line-end)
      :tail-matcher (rx line-start (* space) (= 3 (char "\"'")) line-end)
      :head-mode 'host
      :tail-mode 'host
      :allow-nested nil
      :keep-in-mode 'host
      :fallback-mode 'host)
    (define-polymode poly-elixir-web-mode
      :hostmode 'poly-elixir-hostmode
      :innermodes '(poly-liveview-expr-elixir-innermode))
    )

  (setq web-mode-engines-alist '(("elixir" . "\\.ex\\'")))
#+end_src

** Yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode)
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md\\'")
#+END_SRC

Enable visual line for word wrap and sane navigation.
#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook #'visual-line-mode)
#+END_SRC

** Dockerfile
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :mode ("Dockerfile\\'" . dockerfile-mode))
#+END_SRC

** Lisp
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :hook (emacs-lisp-mode . paredit-mode))

  (use-package evil-paredit
    :hook (emacs-lisp-mode . evil-paredit-mode))

  (use-package slime
    :init
    (setq inferior-lisp-program "sbcl"))
#+END_SRC

** Comments

Banner comments allows adding visibility to the comments. Great for headings.
#+BEGIN_SRC emacs-lisp
  (use-package banner-comment
    :commands banner-comment)
#+END_SRC
* Snippet Support
Add snippet support. Actual snippets live outside of this file. Custom snippets can be saved in ~~/.emacs.d/snippets~ directory.
#+begin_src emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :hook ((prog-mode org-mode) . yas-minor-mode)
    :config
    (yas-reload-all))

  (use-package yasnippet-snippets
    :after (yasnippet))
#+end_src

* Terminal
Add ~vterm~, the most complete terminal emulator for emacs, and supporting packages.

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :commands (vterm))

  (use-package vterm-toggle
    :after vterm
    :commands (vterm-toggle)
    :config
    (setq vterm-toggle-hide-method 'reset-window-configration)
    (evil-collection-define-key 'insert 'vterm-mode-map
      (kbd "M-t") 'vterm-toggle))
  (general-define-key
   :states 'normal
   "M-t" 'vterm-toggle)
#+END_SRC

* Code completion and Error Checking

Using company for auto-completion backend. Most modern languages implement LSP (Language Server Protocol), allowing for rich auto-completion.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish
    :hook (prog-mode . company-mode)
    :init
    (setq company-idle-delay 0)
    (setq company-global-modes '(not org-mode))
    (setq company-minimum-prefix-length 1))

  (use-package eglot
    :after elixir-mode
    :commands (eglot eglot-ensure)
    ;; :hook ((elixir-mode ruby-mode) . eglot-ensure)
    :config
    (add-to-list 'eglot-server-programs '(elixir-mode "/Users/akash/Downloads/elixir-ls/language_server.sh")))

  ;; Helps with monorepo project where projects might not be the top level
  (add-hook 'project-find-functions 'aa/find-mix-project nil nil)
  (add-hook 'project-find-functions 'aa/find-rails-project nil nil)

  (use-package flycheck
    :diminish
    :hook (prog-mode . flycheck-mode)
    :custom
    (flycheck-emacs-lisp-initialize-packages t)
    (flycheck-display-errors-delay 0.1)
    :config
    (flycheck-set-indication-mode 'left-margin)
    (with-eval-after-load 'flycheck
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
    (add-to-list 'flycheck-checkers 'proselint))

  (use-package flycheck-inline
    :hook (prog-mode . flycheck-inline-mode))
#+END_SRC

* Sidebar
#+BEGIN_SRC emacs-lisp
  (use-package dired-sidebar
    :commands (dired-sidebar-toggle-sidebar)
    :after evil
    :init
    (add-hook 'dired-sidebar-mode-hook
              (lambda ()
                (unless (file-remote-p default-directory)
                  (auto-revert-mode))))

    :config
    (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
    (push 'rotate-windows dired-sidebar-toggle-hidden-commands)
    (setq dired-sidebar-theme 'icons)
    (setq dired-sidebar-subtree-line-prefix "-")
    (setq dired-sidebar-use-term-integration t)
    (setq dired-sidebar-use-custom-font t))

  (aa/leader-key-def
    "n" '(dired-sidebar-toggle-sidebar :which-key "sidebar"))
#+END_SRC

Run ~M-x all-the-icons-install-fonts~ to install the icons.
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode)
    :after all-the-icons
    :init
    (setq all-the-icons-dired-monochrome nil))
#+END_SRC

* General Searching
#+BEGIN_SRC emacs-lisp
  (use-package ripgrep)

  (use-package deadgrep
    :commands deadgrep)

  (aa/leader-key-def
    "s" '(deadgrep :which-key "search"))
#+END_SRC

* Sources
Huge thanks to these amazing people whose configs I borrowed from:
- [[https://github.com/meatcar/emacs.d/blob/master/config.org][Denys Pavlov]]
- [[https://github.com/daviwil/dotfiles/blob/master/Emacs.org][David Wilson]]
* Quick keybindings for memory

|------------+---------------------------------------------|
| Keybinding | Explanation                                 |
|------------+---------------------------------------------|
| C-c C-c    | Execute code block                          |
| C-c C-o    | Open source block result                    |
| C-c C-,    | Insert structure template (Eg: Code blocks) |
| C-c '      | Edit the current source code block          |
| srcel<TAB> | Insert elisp code block                     |
|------------+---------------------------------------------|
