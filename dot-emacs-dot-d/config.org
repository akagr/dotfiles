#+AUTHOR: Akash Agrawal
#+EMAIL: akagr@outlook.com
#+PROPERTY: header-args :results silent :tangle "./init.el"
#+STARTUP: content
#+babel: :cache yes

This is my [[https://www.gnu.org/software/emacs/][Emacs]] config, written using [[https://orgmode.org][Org]] in literate environment. I use this primarily on macOS and haven't tested it on other platforms, but I imagine most of the code works with minor to no changes on Linux and possibly Windows too.

* Early Init
:properties:
:header-args+: :tangle "./early-init.el"
:end:

** Check for minimum version
#+BEGIN_SRC emacs-lisp
  (let ((min-version "29"))
    (if (version< emacs-version min-version)
        (error "Emacs version is %s. Minimum required version is %s."
               emacs-version
               min-version)))
#+END_SRC
** Make emacs occupy full screen
#+BEGIN_SRC emacs-lisp
  (setq frame-resize-pixelwise t)
#+END_SRC
** Defer Compilation
#+BEGIN_SRC emacs-lisp
  (defvar comp-deferred-compilation)
  (setq comp-deferred-compilation t)
#+END_SRC

** Speed Boost
#+BEGIN_SRC emacs-lisp
  (setq package-enable-at-startup nil
        frame-inhibit-implied-resize t)
#+END_SRC

** Reduce GC
Following [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][Doom-Emacs FAQ]], we max the garbage collection threshold on startup, and reset it to the original value after.
#+BEGIN_SRC emacs-lisp
  ;; max memory available for gc on startup
  (defvar aa/gc-cons-threshold 16777216)
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold aa/gc-cons-threshold
                    gc-cons-percentage 0.1)))

  ;; max memory available for gc when opening minibuffer
  (defun aa/defer-garbage-collection-h ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun aa/restore-garbage-collection-h ()
    ;; Defer it so that commands launched immediately after will enjoy the
    ;; benefits.
    (run-at-time
     1 nil (lambda () (setq gc-cons-threshold aa/gc-cons-threshold))))

  (add-hook 'minibuffer-setup-hook #'aa/defer-garbage-collection-h)
  (add-hook 'minibuffer-exit-hook #'aa/restore-garbage-collection-h)
  (setq garbage-collection-messages nil)
#+END_SRC

Temporarily avoid special handling of files
#+BEGIN_SRC emacs-lisp
  (defvar aa/-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq file-name-handler-alist aa/-file-name-handler-alist)))
#+END_SRC

** Disable Site Run
#+BEGIN_SRC emacs-lisp
  (setq site-run-file nil)
#+END_SRC

** Don't compact font caches
#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

** Improve I/O
Optimizations for improving I/O performance. Increase max bytes read from a sub-process in a single op (Emacs 27+)
#+BEGIN_SRC emacs-lisp
  (when (boundp 'read-process-output-max)
    ;; 1MB in bytes, default 4096 bytes
    (setq read-process-output-max 1048576))
#+END_SRC

** Straight.el
[[https://github.com/raxod502/straight.el][straight.el]] is used to download packages for us from all over the web. It stores them all in their respective git folders in =.emacs.d/straight=, which makes debugging, and contributing fixes back upstream as easy as possible.

Updating some settings so straight.el can play nicely with use-package.
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t
        straight-cache-autoloads t
        straight-check-for-modifications '(check-on-save)
        straight-vc-git-default-clone-depth 1
        vc-follow-symlinks t)
#+END_SRC

Fetching =straight.el=.
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (setq vc-follow-symlinks 'ask) ; restore default
#+END_SRC

Loading an optional package which gives us some convenience functions, like ~straight-x-clean-unused-repo~ to remove any packages we don't have configured anymore.
#+begin_src emacs-lisp
  (require 'straight-x)
#+end_src

Installing =use-package= now.
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
#+END_SRC

** Use the garbage collector magic hack
#+begin_src emacs-lisp
  (use-package gcmh
    :demand t
    :config (gcmh-mode 1))
  #+end_src
** Set custom file
#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "emacs-custom.el" user-emacs-directory))
  (load custom-file t)
#+END_SRC
** End early init
#+BEGIN_SRC emacs-lisp
  (provide 'early-init)
#+END_SRC

* External Dependencies

- Download ~elixir-ls~ from https://github.com/JakeBecker/elixir-ls and adjust the path of language server in eglot config.

* Bootstrapping and Default

** Setup load path
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+END_SRC

** Update defaults
Turn off auto backup files, startup message and other more sensible defaults.
#+BEGIN_SRC emacs-lisp
  (setq auto-save-default nil
        create-lockfiles nil
        make-backup-files nil
        inhibit-startup-message t
        load-prefer-newer t
        ring-bell-function 'ignore
        sentence-end-double-space nil
        confirm-kill-processes nil)
#+END_SRC

Don't use tabs for indentation. Also truncate lines instead of wrapping them.
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                truncate-lines t)
#+END_SRC

Use y or n instead of yes or no. Additionally, use ibuffers to be consistent with buffer management and not having to worry about wrong key chords.
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  (defalias 'list-buffers 'ibuffer)
#+END_SRC

Turn off all the chrome that emacs puts by default.
#+BEGIN_SRC emacs-lisp
  (progn
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (tooltip-mode -1))
#+END_SRC

A few modes are turned on by default
#+BEGIN_SRC emacs-lisp
  (global-so-long-mode) ;; handles really long lines well
  (column-number-mode) ;; show column number in mode line
  (global-auto-revert-mode) ;; reflect changes on disk to file automatically
  (show-paren-mode) ;; show matching delimiters
  (global-display-line-numbers-mode) ;; show line numbers in all buffers
#+END_SRC

Make the command key behave as 'meta' on macOS.
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq mac-option-key-is-meta nil
          mac-command-key-is-meta t
          mac-command-modifier 'meta
          mac-option-modifier 'super))
#+END_SRC

Delete whitespace on save
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-change-major-mode-hook
            (lambda ()
              (modify-syntax-entry ?_ "w")))
#+END_SRC

* Custom Functions

** Copy current file path relative to project root.
#+BEGIN_SRC emacs-lisp
  (defun aa/copy-file-path ()
    "Copy file path of current buffer relative to project root."
    (interactive)
    (kill-new (file-relative-name buffer-file-name (projectile-project-root))))

  (defalias 'copy-file-path 'aa/copy-file-path)
#+END_SRC

** Kill this buffer and window, as long as it's not the only window open.
#+begin_src emacs-lisp
  (defun aa/close-and-kill-this-pane ()
    "If there are multiple windows, then close this one and kill its buffer"
    (interactive)
    (kill-this-buffer)
    (if (not (one-window-p))
        (delete-window)))
#+end_src

** Add custom methods to correctly locate elixir and rails projects inside a multi-project monorepo.
#+BEGIN_SRC emacs-lisp
  (defun aa/find-mix-project (dir)
    "Try to locate a Elixir project root by 'mix.exs' above DIR."
    (let ((mix_root (locate-dominating-file dir "mix.exs")))
      (message "Found Elixir project root in '%s' starting from '%s'" mix_root dir)
      (if (stringp mix_root) `(transient . ,mix_root) nil)))

  (defun aa/find-rails-project (dir)
    "Try to locate a Rails project root by 'Gemfile' above DIR."
    (let ((rails_root (locate-dominating-file dir "Gemfile")))
      (message "Found Rails project root in '%s' starting from '%s'" rails_root dir)
      (if (stringp rails_root) `(transient . ,rails_root) nil)))
#+END_SRC

** Print emacs startup time
#+BEGIN_SRC emacs-lisp
  (defun aa/print-startup-time ()
    "Log emacs startup time"
    (interactive)
    (message "Emacs started in %s with %d garbage collections."
             (format
              "%.2f seconds"
              (float-time
               (time-subtract after-init-time before-init-time)))
             gcs-done))
#+END_SRC

** Convert strings to dash case
#+BEGIN_SRC emacs-lisp
  (defun aa/dashcase (str)
    "Converts a string to dash case.

     Example:
     (aa/dashcase \"Hello World\")
     => \"hello-world\" "
    (let ((down (downcase str)))
      (replace-regexp-in-string "\\([^A-Za-z]\\)" "-" down)))
#+END_SRC
* Support Packages

Loading emacs from finder or spotlight causes it to not load many environment variables. This package fixes it.
#+BEGIN_SRC emacs-lisp
  (cl-loop for file in '("/opt/homebrew/bin/fish"
                         "/usr/local/bin/fish"
                         "/bin/fish"
                         "/opt/homebrew/bin/zsh"
                         "/usr/local/bin/zsh"
                         "/bin/zsh"
                         "/opt/homebrew/bin/bash"
                         "/usr/local/bin/bash"
                         "/bin/bash")
           when (file-exists-p file)
           do (progn
                (setq shell-file-name file)
                (cl-return)))
  (setenv "SHELL" shell-file-name)

  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

Various packages that are used by numerous other packages.
+ `which-key` allows using keybindings interactively. For example, if `<leader>gs` is mapped to `magit-status`, and I press only `<leader>g`, it'll show all the keys and commands that are valid follows.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode)
    (which-key-setup-side-window-bottom)
    :custom (which-key-idle-delay 0.3))
#+END_SRC

Simplify leader bindings with general.el.
#+begin_src emacs-lisp
  (use-package general
    :config
    (general-evil-setup t)

    (general-create-definer aa/leader-key-def
      :keymaps '(normal insert visual emacs)
      :prefix ","
      :global-prefix "C-,"))
#+end_src
* Common Keybindings

#+BEGIN_SRC emacs-lisp
  (aa/leader-key-def
    "e"  '(:ignore t :which-key "emacs")
    "ee" '((lambda () (interactive) (find-file (expand-file-name "config.org" user-emacs-directory))) :which-key "open config")
    "er" '((lambda () (interactive) (load-file user-init-file)) :which-key "reload config")
    "ek" '(kill-emacs :which-key "kill emacs")

    "f"  '(:ignore t :which-key "file")
    "ff" '(find-file :which-key "find")

    "t"  '(:ignore t :which-key "toggle")
    "tt" '(load-theme :which-key "theme")
    "tw" '(toggle-truncate-lines :which-key "wrap lines")

    "c"  '(:ignore t :which-key "code")
    "ca" '(align-regexp :which-key "align regex")
    "cc" '(xref-find-definitions :which-key "find definitions")
    "ce" '(eval-last-sexp :which-key "eval last sexp")
    "cr" '(xref-find-references :which-key "find references"))
#+END_SRC
* Helpful Instrospection

[[https://github.com/Wilfred/helpful][Helpful]] allows much better help (introspection) pages. For example, when showing help for functions, it shows references, source code etc. all on single page. This reduces jumping to different locations frequently.
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :commands (helpful-callable
               helpful-variable
               helpful-key
               helpful-at-point
               helpful-command
               helpful-macro
               helpful-function))
  (aa/leader-key-def
    "h"  '(help-command :which-key "help")
    "hf" '(helpful-callable :which-key "functions")
    "hg" '(google :which-key "google")
    "hk" '(helpful-key :which-key "key-bindings")
    "hm" '(consult-minor-mode-menu :which-key "consult-minor-mode-menu")
    "hv" '(helpful-variable :which-key "variables"))
#+END_SRC
* Evil Mode

Add undo package to allow branching undos.
#+begin_src emacs-lisp
  (use-package undo-fu)
#+end_src

Being a long time (neo)vim user, I use evil mode exclusively for editing. When they say it's impossible to get out of vim, it has a deeper meaning.
I use different colored cursors to depict what mode I'm in. Way easier to work with than looking at minibuffer.
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq evil-respect-visual-line-mode t
          evil-undo-system 'undo-fu
          evil-want-integration t
          evil-want-keybinding nil)
    :config
    (evil-mode)
    (setq evil-emacs-state-modes (delq 'ibuffer-mode evil-emacs-state-modes)
          evil-emacs-state-cursor '("indian red" box)
          evil-normal-state-cursor '("indian red" box)
          evil-visual-state-cursor '("royal blue" box)
          evil-insert-state-cursor '("yellow green" box)
          evil-replace-state-cursor '("red" box)
          evil-operator-state-cursor '("red" hollow)))
#+END_SRC

Commentary package allows me to retain my muscle memory of (un)commenting code.
#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :after evil
    :config
    (evil-commentary-mode))
#+END_SRC

Evil surround for adding quotes, parenthesis etc. Another takeaway from vim.
#+begin_src emacs-lisp

  (use-package evil-surround
    :after evil
    :config
    (global-evil-surround-mode 1))
#+end_src

[[https://github.com/gabesoft/evil-mc][evil-mc]] adds an awesome multiple cursor mode.
#+BEGIN_SRC emacs-lisp
  (use-package evil-mc
    :config
    (global-evil-mc-mode 1))
#+END_SRC

~evil-collection~ adds evil bindings for packages and modes not covered by ~evil~.
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :init
    (evil-collection-init
     '(dired
       dired-sidebar
       ediff
       embark
       grep
       helpful
       ibuffer
       magit
       man
       occur
       process-menu
       rg
       sly
       smerge
       vterm
       wgrep
       xref
       ztree)))
#+END_SRC

* Org Mode
:properties:
:header-args+: :tangle "./lisp/init-org.el"
:end:

** Load relevant config when org is loaded
This gets placed in ~init.el~ and requires all the code following it related to org mode.
#+BEGIN_SRC emacs-lisp :tangle "./init.el"
  (add-hook 'org-mode-hook
            (lambda ()
              (require 'init-org)))

  (with-eval-after-load 'org
    (setq org-startup-indented t
          org-hide-emphasis-markers t
          org-fontify-done-headline t
          org-hide-leading-stars t
          org-pretty-entities t
          org-src-fontify-natively t
          org-src-tab-acts-natively t
          truncate-lines nil))
#+END_SRC

** Align tags on save
#+BEGIN_SRC emacs-lisp :tangle "./init.el"
  (add-hook 'org-mode-hook
            (lambda ()
              (add-hook 'before-save-hook
                        (lambda ()
                          (org-align-tags t))
                        nil t)))
#+END_SRC

** Set up org default files and directories:

#+begin_src emacs-lisp
  (setq org-directory "~/Dropbox/org"
        org-default-notes-file (concat org-directory "/notes.org")
        org-agenda-files '("~/Dropbox/org/")
        org-archive-location (concat org-directory "/archive/%s::"))
#+end_src

** Show hidden elements under point
#+BEGIN_SRC emacs-lisp
  (use-package org-appear
    :custom
    (org-appear-autolinks t)
    (org-appear-submarkers t)
    (org-appear-delay 0.5)
    :hook (org-mode . org-appear-mode))

  ;; Start once on initial org load.
  ;; The hook above takes care of starting it on subsequent loads.
  (org-appear-mode)
#+END_SRC
** Keybindings for org mode.

#+begin_src emacs-lisp
  (aa/leader-key-def
    "r"  '(:ignore t :which-key "org mode")
    "ra" '(org-agenda :which-key "agenda")
    "rc" '(org-capture :which-key "capture")
    "re" '(org-export-dispatch :which-key "export")
    "ri" '((lambda () (interactive) (org-indent-block)) :which-key "indent block")
    "rl" '(org-store-link :which-key "store Link")
    "ro" '((lambda () (interactive) (find-file org-default-notes-file)) :which-key "open notes")
    "rp" '(org-present :which-key "present")
    "rt" '(org-babel-tangle :which-key "tangle"))
#+end_src

** Enable helpful org-specific minor modes

#+BEGIN_SRC emacs-lisp
  ;; Turn on visual line mode to wrap lines.
  (visual-line-mode)
  (add-hook 'org-mode-hook #'visual-line-mode)

  ;; Turn on variable pitch mode to use different scale for headings
  (variable-pitch-mode)
  (add-hook 'org-mode-hook #'variable-pitch-mode)

  ;; If the source block contains code that outputs images,
  ;; show them inline in results area.
  (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images)
#+END_SRC

** Org bullets

=org-bullets= package prettifies the headline markers.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :custom
    (org-bullets-bullet-list '("☯" "✸" "✿" "✜" "◆" "◉" "▶" "○"))
    :hook (org-mode . org-bullets-mode))

  ;; Start once on initial org load.
  ;; The hook above takes care of starting it on subsequent loads.
  (org-bullets-mode)
#+END_SRC

** Evil org mode

Helps with evil keybindings in =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :hook (org-mode . evil-org-mode)
    :init
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme)))
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))

  ;; Start once on initial org load.
  ;; The hook above takes care of starting it on subsequent loads.
  (evil-org-mode)
#+END_SRC

** Font and text customisation

Replace default block delimiters with ligatures
#+BEGIN_SRC emacs-lisp
  (setq-default prettify-symbols-alist '(("#+BEGIN_SRC" . "λ")
                                         ("#+END_SRC" . "λ")
                                         ("#+begin_src" . "λ")
                                         ("#+end_src" . "λ")))
  (setq prettify-symbols-unprettify-at-point t)

  (prettify-symbols-mode)
  (add-hook 'org-mode-hook 'prettify-symbols-mode)
#+END_SRC

Replace list bullets with prettier dots.
#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([+]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "◦"))))))
#+END_SRC

** Presentations with Org

Add ability to present org files.
#+BEGIN_SRC emacs-lisp
  (use-package org-present
    :commands (org-present)
    :config
    (add-hook 'org-present-mode-hook
                 (lambda ()
                   (display-line-numbers-mode -1)
                   (org-display-inline-images)
                   (org-present-hide-cursor)
                   (org-present-read-only)))
       (add-hook 'org-present-mode-quit-hook
                 (lambda ()
                   (display-line-numbers-mode +1)
                   (org-remove-inline-images)
                   (org-present-show-cursor)
                   (org-present-read-write))))
#+END_SRC
** Org drill
Allows preparing flashcard like interface for spaced repetition and revision. Check out the [[https://gitlab.com/phillord/org-drill/][repo]] for more info.
#+BEGIN_SRC emacs-lisp
  (use-package org-drill
    :commands (org-drill))
#+END_SRC
** Auto tangle this file after save
#+BEGIN_SRC emacs-lisp
  (use-package async
    :demand t)

  (defvar *config-file* (expand-file-name "config.org" user-emacs-directory)
    "The configuration file.")

  (defvar *show-async-tangle-results* nil
    "Keeps *emacs* async buffers around for later inspection.")

  (defun aa/async-babel-tangle (org-file)
    "Tangles the org file asynchronously."
    (let ((init-tangle-start-time (current-time))
          (file (buffer-file-name))
          (async-quiet-switch "-q"))
      (async-start
       `(lambda ()
          (require 'ob-tangle)
          (org-babel-tangle-file ,org-file))
       (unless *show-async-tangle-results*
         `(lambda (result)
            (if result
                (message "SUCCESS: %s successfully tangled (%.2fs)."
                         ,org-file
                         (float-time
                          (time-subtract (current-time)
                                         ',init-tangle-start-time)))
              (message "ERROR: %s as tangle failed." ,org-file)))))))

  (defun aa/config-tangle ()
    "Tangles the org file asynchronously."
    (aa/async-babel-tangle *config-file*))

  (add-hook 'org-mode-hook
            (lambda ()
              (when (and buffer-file-truename
                         (equal (file-name-nondirectory buffer-file-truename)
                                "config.org"))
                (add-hook 'after-save-hook
                          'aa/config-tangle
                          nil 'make-it-local))))
#+END_SRC

** Provide org package

Provide org package for ~require~.
#+BEGIN_SRC emacs-lisp
  (provide 'init-org)
#+END_SRC
* Code folding
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'hs-minor-mode)

  ;; Evil bindings to work with folds
  ;; za - toggle fold
  ;; zc - close fold
  ;; zo - open fold
  ;; zm - close all folds
  ;; zr - open all folds
#+END_SRC
* Better UX for Completions

Add =vertico= to handle all the menu presentation.
#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :init
    (vertico-mode)
    :custom
    (vertico-cycle t))
#+END_SRC

Save history of selections across emacs sessions.
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (savehist-mode))
#+END_SRC

Add =marginalia= for richer annotations in menus.
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :after vertico
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+END_SRC

Add =orderless= for saner ordering and filtering of completion candidates.
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless))
    (completion-category-defaults nil)
    (completion-category-overrides '(file (styles partial-completion))))
#+END_SRC


Add extra completion commands ala =consult=.
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :init
    (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    :config
    (setq consult-project-root-function #'projectile-project-root))
#+END_SRC

=embark= allows 'right-click' behaviour. i.e. it allows adding contextual actions to things.
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :custom
    ;; This effectively disables the comfirmation for anything not
    ;; listed.
    (embark-allow-edit-commands
     '(shell-command async-shell-command pp-eval-expression))

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command
          embark-quit-after-action '((kill-buffer . nil)
                                     (t . nil)))

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))

    (define-key embark-file-map     (kbd "o") #'find-file-other-window)
    (define-key embark-buffer-map   (kbd "o") #'switch-to-buffer-other-window))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :after (embark consult)
    :demand t ;; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

Add common keybindings for buffer.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states 'normal
   "C-s" 'consult-line
   "C-h m" 'consult-minor-mode-menu)
#+END_SRC

* VCS

The primary git interface I use, and also one of the main reasons I use emacs.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands (magit magit-status magit-blame))

  (aa/leader-key-def
    "g" '(:ignore t :which-key "git")
    "gb" '(magit-blame :which-key "blame")
    "gc" '(magit-clone :which-key "clone")
    "gf" '(magit-log-buffer-file :which-key "file history")
    "gs" '(magit-status :which-key "status"))
#+END_SRC

Set ediff to use the current frame instead of creating a new one.
#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

When we use ~emacsclient~, we need to export ~$EDITOR~ environment variable to correctly work with git.
#+BEGIN_SRC emacs-lisp
  (use-package with-editor
    :after magit
    :config
    (define-key (current-global-map)
                [remap async-shell-command] 'with-editor-async-shell-command)
    (define-key (current-global-map)
                [remap shell-command] 'with-editor-shell-command)
    (add-hook 'vterm-mode-hook 'with-editor-export-editor))
#+END_SRC

* Diffs
~ztree~ allows diffing entire directories, instead of buffers or files. Handy when you have multiple projects
based on same template and are looking for drifts or differences.
#+BEGIN_SRC emacs-lisp
  (use-package ztree
    :config
    (defun diff-directories ()
      "Thin wrapper over ztree-diff to be more discoverable"
      (interactive)
      (call-interactively 'ztree-diff)))

#+END_SRC
* Buffer and window management
** Ace window
~ace-window~ allows quickly switching between open windows (splits).
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :commands (ace-window)
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (aw-background nil))
#+END_SRC
** Buffer keybindings
#+BEGIN_SRC emacs-lisp
  (aa/leader-key-def
  "b"   '(:ignore t :which-key "buffer")
  "bb"  '(consult-buffer :which-key "list buffers")
  "bB"  '(ibuffer :which-key "ibuffer")
  "bc"  '(kill-this-buffer :which-key "kill current")
  "bd"  '(aa/close-and-kill-this-pane :which-key "close current"))
#+END_SRC
** Window Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "M-o" 'ace-window)

  (aa/leader-key-def
    "w"   '(:ignore t :which-key "window")
    "w="  '(balance-windows :which-key "balance")
    "w>"  '(evil-window-increase-width :which-key "width+︎")
    "w<"  '(evil-window-decrease-width :which-key "width-")
    "w+"  '(evil-window-increase-height :which-key "height+")
    "w-"  '(evil-window-decrease-height :which-key "height-")
    "wc"  '(evil-window-delete :which-key "close")
    "wq"  '(evil-window-delete :which-key "close")
    "wh"  '(evil-window-split :which-key "horizontal")
    "wo"  '(delete-other-windows :which-key "only")
    "wr"  '(evil-window-rotate-upwards :which-key "rotate")
    "ww"  '(evil-window-vsplit :which-key "vertical")
    "wm"  '(:ignore t :which-key "move")
    "wmh" '(evil-window-move-far-left :which-key "left")
    "wmj" '(evil-window-move-very-bottom :which-key "down")
    "wmk" '(evil-window-move-very-top :which-key "up")
    "wml" '(evil-window-move-far-right :which-key "right"))

#+END_SRC
** Ibuffer

*** Ibuffer projectile integration
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-vc
    :init
    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (unless (eq ibuffer-sorting-mode 'alphabetic)
                  (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC

*** Do not show empty groups
#+BEGIN_SRC emacs-lisp
  (setq ibuffer-show-empty-filter-groups nil)
#+END_SRC
* Dired

Set directories to be listed above files.
#+BEGIN_SRC emacs-lisp
  (defun aa/dired-sort-directories ()
    "Sort dired listings with directories first."
    (save-excursion
      (let (buffer-read-only)
        (forward-line 2) ;; beyond dir. header
        (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
      (set-buffer-modified-p nil)))

  (defadvice dired-readin
    (after dired-after-updating-hook first () activate)
    "Sort dired listings with directories first before adding marks."
    (aa/dired-sort-directories))
#+END_SRC

* Project Management

Projectile plays pretty well with the other packages, including magit and dired sidebar.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :after evil
    :init
    (setq projectile-enable-caching t)
    :config
    (define-key projectile-mode-map (kbd "M-p") 'projectile-command-map)
    (projectile-mode +1))

  (aa/leader-key-def
    "p"  '(projectile-command-map :which-key "projectile"))
#+END_SRC

* Programming Languages
** Tree sitter
[[https://emacs-tree-sitter.github.io][Tree sitter]] allows incremental parsing of syntax for highlighting. This beats regex based parsing which doesn't work so good.
#+BEGIN_SRC emacs-lisp
  (use-package tree-sitter)
  (use-package tree-sitter-langs
    :after tree-sitter)
  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-mode-hook 'tree-sitter-hl-mode)
#+END_SRC
** Common Config
#+begin_src emacs-lisp
  (use-package editorconfig
    :config
    (editorconfig-mode 1))
#+end_src
** Ruby
Rubocop is the de-facto lint and syntax checker for ruby.
#+BEGIN_SRC emacs-lisp
  (use-package rubocop
    :hook (ruby-mode . rubocop-mode)
    :custom
    (rubocop-autocorrect-on-save t))
#+END_SRC
** Typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode ("\\.tsx?\\'" . typescript-mode))

  (use-package prettier
    :hook (typescript-mode javascript-mode))
#+end_src
** Elixir
#+BEGIN_SRC emacs-lisp
  (use-package elixir-mode
    :mode "\\.exs?\\'"
    :config
    ;; Create a buffer-local hook to run elixir-format on save, only when we enable elixir-mode.
    (add-hook 'elixir-mode-hook
              (lambda () (add-hook 'before-save-hook 'elixir-format nil t))))
#+END_SRC
** Web
#+begin_src emacs-lisp
  (use-package web-mode
    :mode "\\.p?html?\\'"
    :mode "\\.eex\\'"
    :mode "\\.leex\\'"

    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-enable-auto-closing t
          web-mode-enable-auto-opening t
          web-mode-enable-auto-pairing t
          web-mode-enable-auto-indentation t))
#+end_src

** Yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode)
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md\\'")
#+END_SRC

Enable visual line for word wrap and sane navigation.
#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook #'visual-line-mode)
#+END_SRC

** Dockerfile
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :mode ("Dockerfile\\'" . dockerfile-mode))
#+END_SRC

** Jenkins
#+BEGIN_SRC emacs-lisp
  (use-package jenkinsfile-mode
    :mode ("\\`Jenkinsfile'" . typescript-mode))
#+END_SRC
** Lisp

*** Smartparens - Structured Lisp editing
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :init
    (smartparens-global-mode)
    :hook ((emacs-lisp-mode lisp-mode) . smartparens-strict-mode)
    :config
    (require 'smartparens-config)
    (sp-use-smartparens-bindings)
    (custom-set-variables
     '(sp-override-key-bindings
       '(("M-T" . sp-transpose-sexp)
         ("M-(" . sp-wrap-round)
         ("M-{" . sp-wrap-curly)
         ("M-[" . sp-wrap-square)
         ("M-r" . sp-raise-sexp)
         ("M-<right>" . sp-forward-slurp-sexp)
         ("M-<left>" . sp-backward-slurp-sexp)
         ("M-S-<right>" . sp-forward-barf-sexp)
         ("M-S-<left>" . sp-backward-barf-sexp)
         ("C-<up>" . sp-backward-up-sexp)
         ("C-S-<up>" . sp-up-sexp)
         ("C-<down>" . sp-down-sexp)
         ("C-S-<down>" . sp-backward-down-sexp)
         ("C-<right>" . sp-forward-sexp)
         ("C-<left>" . sp-backward-sexp)))))

  (use-package evil-smartparens
    :after (smartparens)
    :hook ((smartparens-strict-mode) . evil-smartparens-mode))
#+END_SRC

*** Sly - Interactive Lisp development
#+BEGIN_SRC emacs-lisp
  (use-package sly
    :commands sly
    :config
    (setq inferior-lisp-program "sbcl"))

  (use-package sly-asdf
    :after sly)

  (use-package sly-quicklisp
    :after sly)
#+END_SRC

** Comments

Banner comments allows adding visibility to the comments. Great for headings.
#+BEGIN_SRC emacs-lisp
  (use-package banner-comment
    :commands banner-comment)
#+END_SRC

** Terraform
#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode
    :mode "\\.tf\\'")
#+END_SRC
* Snippet Support
Add snippet support. Actual snippets live outside of this file. Custom snippets can be saved in ~~/.emacs.d/snippets~ directory.
#+begin_src emacs-lisp
  (use-package yasnippet
    :hook ((prog-mode org-mode) . yas-minor-mode)
    :config
    (yas-reload-all))

  (use-package yasnippet-snippets
    :after (yasnippet))
#+end_src

* Terminal
Add ~vterm~, the most complete terminal emulator for emacs, and supporting packages.

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :commands (vterm)
    :config
    (add-hook 'vterm-mode-hook (lambda () (display-line-numbers-mode -1))))

  (use-package multi-vterm
    :commands (multi-vterm
               multi-vterm-dedicated-toggle
               multi-vterm-dedicated-open)
    :config
    (evil-collection-define-key 'insert 'vterm-mode-map
      (kbd "M-t") 'multi-vterm-dedicated-toggle))
  (general-define-key
   :states 'normal
   "M-t" 'multi-vterm-dedicated-toggle)
#+END_SRC

* Code completion and Error Checking

Using ~corfu~ for auto-completion backend. Most modern languages implement LSP (Language Server Protocol), allowing for rich auto-completion.
#+BEGIN_SRC emacs-lisp
  (use-package corfu
    ;; TAB-and-Go customizations
    :custom
    (corfu-auto t)
    (corfu-echo-documentation t)
    (corfu-auto-prefix 1)
    (corfu-cycle t)             ;; Enable cycling for `corfu-next/previous'
    (corfu-preselect-first nil) ;; Disable candidate preselection
    (corfu-quit-no-match t)
    (corfu-quit-at-boundary t)

    ;; Use TAB for cycling, default is `corfu-complete'.
    :bind
    (:map corfu-map
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous))

    :init
    (global-corfu-mode))
#+END_SRC

Cape allows adding various inbuilt completion candidates to the =completion-at-point-functions= which ~corfu~ uses.
#+BEGIN_SRC emacs-lisp
  (use-package cape
    :after corfu
    :init
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-keyword))

  (use-package cape-yasnippet
    :straight (cape-yasnippet :type git :host github :repo "elken/cape-yasnippet")
    :after cape
    :init
    (add-to-list 'completion-at-point-functions #'cape-yasnippet))
#+END_SRC

=kind-icon= bring icons for completion candidates. It makes it easy to spot the type of completion (function vs variable) at a glance.
#+BEGIN_SRC emacs-lisp
  (use-package kind-icon
    :straight (kind-icon :type git :host github :repo "jdtsmith/kind-icon")
    :after corfu
    :custom
    (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+END_SRC

Eldoc is built-in emacs documentation viewer. By default, the documentation for symbol at-point appears in minibar, which is often truncated.
This package shows the information as a hover childframe up top. Much easier to consume.
#+BEGIN_SRC emacs-lisp
  (use-package eldoc-box
    :hook (prog-mode . eldoc-box-hover-mode))
#+END_SRC

Eglot is an awesome LSP (language server protocol) package. It gives IDE intellisense like completions for supporting language stacks.
Also helps with errors and accessing documentation, as well as visiting definitions and references.
#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :commands (eglot eglot-ensure)
    ;; :hook ((elixir-mode ruby-mode) . eglot-ensure)
    :config
    (add-to-list 'eglot-server-programs
                 '(terraform-mode . ("terraform-ls" "serve"))))

  ;; Helps with monorepo project where projects might not be the top level
  ;; (add-hook 'project-find-functions 'aa/find-mix-project nil nil)
  ;; (add-hook 'project-find-functions 'aa/find-rails-project nil nil)

  (use-package flycheck
    :hook (prog-mode . flycheck-mode)
    :custom
    (flycheck-emacs-lisp-initialize-packages t)
    (flycheck-display-errors-delay 0.1)
    :config
    (flycheck-set-indication-mode 'left-margin)
    (with-eval-after-load 'flycheck
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
    (add-to-list 'flycheck-checkers 'proselint))

  (use-package flycheck-inline
    :hook (prog-mode . flycheck-inline-mode))
#+END_SRC

* Sidebar
#+BEGIN_SRC emacs-lisp
  (use-package dired-sidebar
    :commands (dired-sidebar-toggle-sidebar)
    :after evil
    :init
    (add-hook 'dired-sidebar-mode-hook
              (lambda ()
                (unless (file-remote-p default-directory)
                  (auto-revert-mode))))

    :config
    (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
    (push 'rotate-windows dired-sidebar-toggle-hidden-commands)
    (setq dired-sidebar-theme 'icons)
    (setq dired-sidebar-subtree-line-prefix "-")
    (setq dired-sidebar-use-term-integration t)
    (setq dired-sidebar-use-custom-font t))

  (aa/leader-key-def
    "n" '(dired-sidebar-toggle-sidebar :which-key "sidebar"))
#+END_SRC

Run ~M-x all-the-icons-install-fonts~ to install the icons.
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode)
    :after all-the-icons
    :init
    (setq all-the-icons-dired-monochrome nil))
#+END_SRC

* General Searching
#+BEGIN_SRC emacs-lisp

  (use-package rg
    :commands rg)

  (aa/leader-key-def
    "s" '(rg-project :which-key "search"))

  (evil-collection-define-key 'normal 'rg-mode-map
    "?" 'rg-menu)
#+END_SRC

* Search google
I wrote this function that lets me quickly search google with thing under point, or selection if it's active. Default browser is used.
#+BEGIN_SRC emacs-lisp
  (defun google (text)
    "Search the text in google using default browser"
    (interactive (list (read-from-minibuffer
                        "Search: "
                        (if (region-active-p)
                            (buffer-substring (region-beginning) (region-end))
                          (thing-at-point 'word)))))
    (browse-url (format "https://google.com/search?q=%s" (url-hexify-string text))))
#+END_SRC
* Appearance
** Frame dimensions

Set default frame height.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(width . 200))
  (add-to-list 'default-frame-alist '(height . 48))
#+END_SRC

** Font
#+BEGIN_SRC emacs-lisp
  (defvar aa/font "JetBrains Mono")
  (defun aa/apply-fonts (frame)
    "Apply selected fonts to emacs."

    ;; Set the font face based on platform
    (set-face-attribute 'default frame
                        :font aa/font
                        :weight 'regular
                        :height 150)

    ;; Set the fixed pitch face
    (set-face-attribute 'fixed-pitch frame
                        :font aa/font
                        :weight 'regular
                        :height 150)

    ;; Set the variable pitch face
    (set-face-attribute 'variable-pitch frame
                        :font aa/font
                        :height 150
                        :weight 'regular))

  (add-hook 'after-make-frame-functions
            (lambda (frame)
              (with-selected-frame frame
                (aa/apply-fonts frame))))

  (aa/apply-fonts nil)
#+END_SRC

Enable ligature support by using auto composition mode. This is tested working with =Jetbrains Mono=. May or may not work with other fonts.
#+BEGIN_SRC emacs-lisp
  (let ((ligatures `((?-  . ,(regexp-opt '("-|" "-~" "---" "-<<" "-<" "--" "->" "->>" "-->")))
                     (?/  . ,(regexp-opt '("/**" "/*" "///" "/=" "/==" "/>" "//")))
                     (?*  . ,(regexp-opt '("*>" "***" "*/")))
                     (?<  . ,(regexp-opt '("<-" "<<-" "<=>" "<=" "<|" "<||" "<|||::=" "<|>" "<:" "<>" "<-<"
                                           "<<<" "<==" "<<=" "<=<" "<==>" "<-|" "<<" "<~>" "<=|" "<~~" "<~"
                                           "<$>" "<$" "<+>" "<+" "</>" "</" "<*" "<*>" "<->" "<!--")))
                     (?:  . ,(regexp-opt '(":>" ":<" ":::" "::" ":?" ":?>" ":=")))
                     (?=  . ,(regexp-opt '("=>>" "==>" "=/=" "=!=" "=>" "===" "=:=" "==")))
                     (?!  . ,(regexp-opt '("!==" "!!" "!=")))
                     (?>  . ,(regexp-opt '(">]" ">:" ">>-" ">>=" ">=>" ">>>" ">-" ">=")))
                     (?&  . ,(regexp-opt '("&&&" "&&")))
                     (?|  . ,(regexp-opt '("|||>" "||>" "|>" "|]" "|}" "|=>" "|->" "|=" "||-" "|-" "||=" "||")))
                     (?.  . ,(regexp-opt '(".." ".?" ".=" ".-" "..<" "...")))
                     (?+  . ,(regexp-opt '("+++" "+>" "++")))
                     (?\[ . ,(regexp-opt '("[||]" "[<" "[|")))
                     (?\{ . ,(regexp-opt '("{|")))
                     (?\? . ,(regexp-opt '("??" "?." "?=" "?:")))
                     (?#  . ,(regexp-opt '("####" "###" "#[" "#{" "#=" "#!" "#:" "#_(" "#_" "#?" "#(" "##")))
                     (?\; . ,(regexp-opt '(";;")))
                     (?_  . ,(regexp-opt '("_|_" "__")))
                     (?\\ . ,(regexp-opt '("\\" "\\/")))
                     (?~  . ,(regexp-opt '("~~" "~~>" "~>" "~=" "~-" "~@")))
                     (?$  . ,(regexp-opt '("$>")))
                     (?^  . ,(regexp-opt '("^=")))
                     (?\] . ,(regexp-opt '("]#"))))))
    (dolist (char-regexp ligatures)
      (set-char-table-range composition-function-table (car char-regexp)
                            `([,(cdr char-regexp) 0 font-shape-gstring]))))
#+END_SRC

Disable auto composition everywhere outside of prog-mode.
#+BEGIN_SRC emacs-lisp
  (global-auto-composition-mode -1)

  (defun aa/enable-auto-composition ()
    (auto-composition-mode))

  (add-hook 'prog-mode-hook #'aa/enable-auto-composition)
#+END_SRC

** Theme

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

  (use-package doom-themes
    :config
    (load-theme 'doom-nord t))
#+END_SRC

** Mode line

Config for mode line:
#+begin_src emacs-lisp
  (use-package doom-modeline
    :demand
    :config
    (doom-modeline-mode 1))
#+end_src
** Natural transparent title bar
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
  (setq ns-use-proxy-icon nil)
#+END_SRC
* Sources
Huge thanks to these amazing people whose configs I borrowed from:
- [[https://github.com/meatcar/emacs.d/blob/master/config.org][Denys Pavlov]]
- [[https://github.com/daviwil/dotfiles/blob/master/Emacs.org][David Wilson]]
* Quick keybindings for memory

|------------+---------------------------------------------|
| Keybinding | Explanation                                 |
|------------+---------------------------------------------|
| C-c C-c    | Execute code block                          |
| C-c C-o    | Open source block result                    |
| C-c C-,    | Insert structure template (Eg: Code blocks) |
| C-c '      | Edit the current source code block          |
| srcel<TAB> | Insert elisp code block                     |
|------------+---------------------------------------------|
